---
links:
  - label: Auth Service
    to: https://jamflow.cloud/auth-service
title: "Auth Module: Client Guide"
description: "JAMflow Authentication and Authorization"
navigation:
  icon: i-lucide-chromium
---

This module ships a collection of Vue composables and Nuxt plugins that make it easy to work with Jamflow Auth Service inside Nuxt applications. This document walks through the client-facing primitives, how they interact with the Auth backend, and how to integrate them in your app.

::warning
**Prerequisites**

- Your Auth Service instance needs to be deployed in your service contract.
- The module must be registered in `nuxt.config.ts` and configured with at least `issuer` and `audience`.
- Cookies for ID, access, and refresh tokens are managed automatically by the module; ensure they are not blocked by your deployment setup.
::

## Session bootstrap

Two Nuxt plugins are in charge of keeping the session fresh across navigation and hydration:

- `session.server`: runs before the server render. It populates the payload with a `isCached` flag and, when the request is freshly rendered, calls `useUserSession().fetch()` to decode the latest ID and access tokens.
- `session.client`: runs on the client during hydration. If the page was delivered from payload cache or static prerendering, it fetches the session after the app mounts to avoid serving stale data.

You normally do not need to import these plugins manually; they are auto-registered when the module is installed.

## `useUserSession()`

`useUserSession` is the primary composable exposed by the module. It transparently refreshes cookies, talks to the server proxy routes, and exposes reactive state for the logged-in user.

```ts
const {
  user,       // Computed<IDTokenClaims | null>
  access,     // Computed<AccessTokenClaims | null>
  loggedIn,   // Computed<boolean>
  login,
  requestAccess,
  fetch,
  refresh,
  clear,
} = useUserSession()
```

### State accessors

- `user`: ID token claims (subject, email, team, etc.). `null` when the visitor is anonymous or the token can't be verified.
- `access`: Access token claims, including the serialized permission codes that drive `usePermissions`.
- `loggedIn`: Convenience boolean derived from `user`.

### Actions

- `login(email, password)`: Calls `/_auth-api/auth/login`, sets cookies, fetches access permissions, and resolves when the session is ready.
- `requestAccess(teamId?)`: Manually request a fresh access token for the current user. This is useful when switching team contexts.
- `fetch()`: Re-reads cookies, validates tokens against the JWKS endpoint, and updates local state. You rarely call this directly because the plugins do it for you.
- `refresh()`: Uses the refresh token endpoint to obtain new ID and access tokens.
- `clear()`: Logs the user out by deleting cookies via `/_auth-api/auth/session` endpoint and resetting in-memory state.

### Working with fetch contexts

The composable automatically switches between `$fetch` on the client and the request-scoped `$fetch` on the server. This is particularly important when building custom plugins or middlewares. It means the same code works in components, server routes, and Nitro handlers without additional wiring.

## Handling permissions with `usePermissions()`

Permissions are encoded in your access token as short codes (for example `@blog:cru` for global create/read/update on the `blog` topic). `usePermissions` translates those strings into a descriptive data structure and gives you helpers to guard UI and pages.

```ts
const { permissions, hasPermission, pagePermission } = usePermissions()
```

- `permissions`: A computed object of type `DecryptedPermissions` separating `team` and `global` scopes.
- `hasPermission(check)`: Return `true` if the current access token grants all requested actions for the given topic. Set `check.team = true` to look at team-scoped grants; otherwise the global scope is used.
- `pagePermission(check, { redirect? })`: Returns the full `ResourcePermissions` object for the topic. When the user lacks access you can opt-in to a redirect (default `'/'`). Without redirect it resolves to an object with all actions set to `false` so that you can render a warning state.

### Example: guarding a page

```vue
const { pagePermission } = usePermissions()

<script setup lang="ts">
const blogPerms = await pagePermission({
  topic: 'blog-posts',
  actions: ['read'],
})
</script>

<template>
  <section v-if="blogPerms.read">
    <!-- Secured content -->
  </section>
  <NuxtErrorBoundary v-else>
    <p>You don't have access to blog posts yet.</p>
  </NuxtErrorBoundary>
</template>
```

### Example: feature flagging UI controls

```vue
<script setup lang="ts">
const { hasPermission } = usePermissions()

const canPublish = computed(() => hasPermission({
  topic: 'blog-posts',
  actions: ['execute'],
}))
</script>

<template>
  <UButton :disabled="!canPublish">Publish</UButton>
</template>
```

## Token lifecycle

- Cookies are refreshed automatically on every call to `fetch()` and `refresh()` via Nuxt's `refreshCookie` helper.
- When an access token is expired, `useUserSession` transparently requests a fresh one and forwards Set-Cookie headers from the API to the browser.
- JWKS keys are cached in memory for up to one hour to avoid unnecessary network traffic.

## Troubleshooting

| Symptom | Likely cause | Fix |
| --- | --- | --- |
| `useUserSession().user` is always `null` | Missing or invalid `issuer` / `audience` runtime config | Verify `nuxt.config` and environment variables. |
| Login succeeds but permissions are empty | Access token not requested, or permission codes not configured server-side | Ensure `requestAccess()` runs after login and the Auth Service issues permissions. |
| Client navigations forget session | Cookies blocked by domain or secure flag mismatch | Check deployment base URL and cookie configuration in the service. |

## Next steps

- Review the [Server-side Guide](/en/auth-module/server-guide.md) for Nitro utilities you can use in API routes.
- Keep an eye on token expiration in long-lived tabs; consider calling `useUserSession().refresh()` from a silent timer if your UX requires it.
